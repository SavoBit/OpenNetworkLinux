diff -urpN a/drivers/hwmon/accton_as5812_54t_psu.c b/drivers/hwmon/accton_as5812_54t_psu.c
--- a/drivers/hwmon/accton_as5812_54t_psu.c	2017-02-09 19:33:53.928298176 +0000
+++ b/drivers/hwmon/accton_as5812_54t_psu.c	2017-02-09 19:42:29.136309356 +0000
@@ -32,15 +32,23 @@
 #include <linux/sysfs.h>
 #include <linux/slab.h>
 
+
+#define PSU_STATUS_I2C_ADDR			0x60
+#define PSU_STATUS_I2C_REG_OFFSET	0x2
+
+#define IS_POWER_GOOD(id, value)	(!!(value & BIT(id*4 + 1)))
+#define IS_PRESENT(id, value)		(!(value & BIT(id*4)))
+
 static ssize_t show_index(struct device *dev, struct device_attribute *da, char *buf);
 static ssize_t show_status(struct device *dev, struct device_attribute *da, char *buf);
 static ssize_t show_model_name(struct device *dev, struct device_attribute *da, char *buf);
 static int as5812_54t_psu_read_block(struct i2c_client *client, u8 command, u8 *data,int data_len);
 extern int accton_i2c_cpld_read(unsigned short cpld_addr, u8 reg);
+static int as5812_54t_psu_model_name_get(struct device *dev);
 
 /* Addresses scanned 
  */
-static const unsigned short normal_i2c[] = { 0x38, 0x3b, 0x50, 0x53, I2C_CLIENT_END };
+static const unsigned short normal_i2c[] = { I2C_CLIENT_END };
 
 /* Each client has this additional data 
  */
@@ -94,11 +102,15 @@ static ssize_t show_status(struct device
     struct as5812_54t_psu_data *data = as5812_54t_psu_update_device(dev);
     u8 status = 0;
 
+    if (!data->valid) {
+        return sprintf(buf, "0\n");
+    }
+
     if (attr->index == PSU_PRESENT) {
-        status = !(data->status >> ((data->index - 1) * 4) & 0x1);
+        status = IS_PRESENT(data->index, data->status);
     }
     else { /* PSU_POWER_GOOD */
-        status = data->status >> ((data->index - 1) * 4 + 1) & 0x1;
+        status = IS_POWER_GOOD(data->index, data->status);
     }
 
     return sprintf(buf, "%d\n", status);
@@ -108,8 +120,20 @@ static ssize_t show_model_name(struct de
              char *buf)
 {
     struct as5812_54t_psu_data *data = as5812_54t_psu_update_device(dev);
-    
-    return sprintf(buf, "%s", data->model_name);
+
+    if (!data->valid) {
+        return 0;
+    }
+
+    if (!IS_PRESENT(data->index, data->status)) {
+        return 0;
+    }
+
+    if (as5812_54t_psu_model_name_get(dev) < 0) {
+        return -ENXIO;
+    }
+
+    return sprintf(buf, "%s\n", data->model_name);
 }
 
 static const struct attribute_group as5812_54t_psu_group = {
@@ -135,6 +159,7 @@ static int as5812_54t_psu_probe(struct i
 
     i2c_set_clientdata(client, data);
     data->valid = 0;
+    data->index = dev_id->driver_data;
     mutex_init(&data->update_lock);
 
     dev_info(&client->dev, "chip found\n");
@@ -151,14 +176,6 @@ static int as5812_54t_psu_probe(struct i
         goto exit_remove;
     }
 
-    /* Update PSU index */
-    if (client->addr == 0x38 || client->addr == 0x50) {
-        data->index = 1;
-    }
-    else if (client->addr == 0x3b || client->addr == 0x53) {
-        data->index = 2;
-    }
-
     dev_info(&client->dev, "%s: psu '%s'\n",
          dev_name(data->hwmon_dev), client->name);
     
@@ -184,8 +201,15 @@ static int as5812_54t_psu_remove(struct
     return 0;
 }
 
+enum psu_index 
+{ 
+    as5812_54t_psu1, 
+    as5812_54t_psu2
+};
+
 static const struct i2c_device_id as5812_54t_psu_id[] = {
-    { "as5812_54t_psu", 0 },
+    { "as5812_54t_psu1", as5812_54t_psu1 },
+    { "as5812_54t_psu2", as5812_54t_psu2 },
     {}
 };
 MODULE_DEVICE_TABLE(i2c, as5812_54t_psu_id);
@@ -219,6 +243,76 @@ abort:
     return result;
 }
 
+enum psu_type {
+    PSU_YM_2401_JCR,    /* AC110V - F2B */
+    PSU_YM_2401_JDR,    /* AC110V - B2F */
+    PSU_CPR_4011_4M11,  /* AC110V - F2B */
+    PSU_CPR_4011_4M21,  /* AC110V - B2F */
+    PSU_CPR_6011_2M11,  /* AC110V - F2B */
+    PSU_CPR_6011_2M21,  /* AC110V - B2F */
+    PSU_UM400D_01G,     /* DC48V  - F2B */
+    PSU_UM400D01_01G    /* DC48V  - B2F */
+};
+
+struct model_name_info {
+    enum psu_type type;
+    u8 offset;
+    u8 length;
+    char* model_name;
+};
+
+struct model_name_info models[] = {
+{PSU_YM_2401_JCR,   0x20, 11, "YM-2401JCR"},
+{PSU_YM_2401_JDR,   0x20, 11, "YM-2401JDR"},
+{PSU_CPR_4011_4M11, 0x26, 13, "CPR-4011-4M11"},
+{PSU_CPR_4011_4M21, 0x26, 13, "CPR-4011-4M21"},
+{PSU_CPR_6011_2M11, 0x26, 13, "CPR-6011-2M11"},
+{PSU_CPR_6011_2M21, 0x26, 13, "CPR-6011-2M21"},
+{PSU_UM400D_01G,    0x50,  9, "um400d01G"},
+{PSU_UM400D01_01G,  0x50, 12, "um400d01-01G"},
+};
+
+static int as5812_54t_psu_model_name_get(struct device *dev)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct as5812_54t_psu_data *data = i2c_get_clientdata(client);
+    int i, status;
+
+    for (i = 0; i < ARRAY_SIZE(models); i++) {
+        memset(data->model_name, 0, sizeof(data->model_name));
+
+        status = as5812_54t_psu_read_block(client, models[i].offset,
+                                           data->model_name, models[i].length);
+        if (status < 0) {
+            data->model_name[0] = '\0';
+            dev_dbg(&client->dev, "unable to read model name from (0x%x) offset(0x%x)\n", 
+                                  client->addr, models[i].offset);
+            return status;
+        }
+        else {
+            data->model_name[models[i].length] = '\0';
+        }
+
+        if (i == PSU_YM_2401_JCR || i == PSU_YM_2401_JDR) {
+            /* Skip the meaningless data byte 8*/
+            data->model_name[8] = data->model_name[9];
+            data->model_name[9] = data->model_name[10];
+            data->model_name[10] = '\0';
+        }
+
+        /* Determine if the model name is known, if not, read next index
+         */
+        if (strncmp(data->model_name, models[i].model_name, models[i].length) == 0) {
+            return 0;
+        }
+        else {
+            data->model_name[0] = '\0';
+        }
+    }
+
+    return -ENODATA;
+}
+
 static struct as5812_54t_psu_data *as5812_54t_psu_update_device(struct device *dev)
 {
     struct i2c_client *client = to_i2c_client(dev);
@@ -231,41 +325,24 @@ static struct as5812_54t_psu_data *as581
         int status = -1;
 
         dev_dbg(&client->dev, "Starting as5812_54t update\n");
-
-        /* Read model name */
-        if (client->addr == 0x38 || client->addr == 0x3b) {
-            /* AC power */
-            status = as5812_54t_psu_read_block(client, 0x26, data->model_name, 
-                                               ARRAY_SIZE(data->model_name)-1);
-        }
-        else {
-            /* DC power */
-            status = as5812_54t_psu_read_block(client, 0x50, data->model_name, 
-                                               ARRAY_SIZE(data->model_name)-1);            
-        }
-        
-        if (status < 0) {
-            data->model_name[0] = '\0';
-            dev_dbg(&client->dev, "unable to read model name from (0x%x)\n", client->addr);
-        }
-        else {
-            data->model_name[ARRAY_SIZE(data->model_name)-1] = '\0';
-        }
+        data->valid = 0;
 
         /* Read psu status */
-        status = accton_i2c_cpld_read(0x60, 0x2);
-        
+        status = accton_i2c_cpld_read(PSU_STATUS_I2C_ADDR, PSU_STATUS_I2C_REG_OFFSET);
+
         if (status < 0) {
-            dev_dbg(&client->dev, "cpld reg 0x60 err %d\n", status);
+            dev_dbg(&client->dev, "cpld reg (0x%x) err %d\n", PSU_STATUS_I2C_ADDR, status);
+            goto exit;
         }
         else {
             data->status = status;
         }
-        
+
         data->last_updated = jiffies;
         data->valid = 1;
     }
 
+exit:
     mutex_unlock(&data->update_lock);
 
     return data;
@@ -273,10 +350,10 @@ static struct as5812_54t_psu_data *as581
 
 static int __init as5812_54t_psu_init(void)
 {
-	extern int platform_accton_as5812_54t(void);
-	if (!platform_accton_as5812_54t()) {
-		return -ENODEV;
-	}
+    extern int platform_accton_as5812_54t(void);
+    if (!platform_accton_as5812_54t()) {
+        return -ENODEV;
+    }
 
     return i2c_add_driver(&as5812_54t_psu_driver);
 }
diff -urpN a/drivers/hwmon/ym2651y.c b/drivers/hwmon/ym2651y.c
--- a/drivers/hwmon/ym2651y.c	2017-02-09 19:33:53.920298176 +0000
+++ b/drivers/hwmon/ym2651y.c	2017-02-09 19:42:29.136309356 +0000
@@ -36,7 +36,12 @@
 
 /* Addresses scanned
  */
-static const unsigned short normal_i2c[] = { 0x58, 0x5b, I2C_CLIENT_END };
+static const unsigned short normal_i2c[] = { I2C_CLIENT_END };
+
+enum chips {
+	YM2651,
+	YM2401,
+};
 
 /* Each client has this additional data
  */
@@ -45,6 +50,7 @@ struct ym2651y_data {
 	struct mutex		update_lock;
 	char				valid;		   /* !=0 if registers are valid */
 	unsigned long	   last_updated;	/* In jiffies */
+	u8	 chip;			/* chip id */
 	u8   capability;	 /* Register value */
 	u16  status_word;	/* Register value */
 	u8   fan_fault;	  /* Register value */
@@ -52,13 +58,14 @@ struct ym2651y_data {
 	u16  v_out;		  /* Register value */
 	u16  i_out;		  /* Register value */
 	u16  p_out;		  /* Register value */
+	u8   vout_mode;		/* Register value */
 	u16  temp;		   /* Register value */
 	u16  fan_speed;	  /* Register value */
 	u16  fan_duty_cycle[2];  /* Register value */
 	u8   fan_dir[5];	 /* Register value */
 	u8   pmbus_revision; /* Register value */
 	u8   mfr_id[10];	 /* Register value */
-	u8   mfr_model[10];  /* Register value */
+	u8   mfr_model[16]; /* Register value */
 	u8   mfr_revsion[3]; /* Register value */
 	u16  mfr_vin_min;	/* Register value */
 	u16  mfr_vin_max;	/* Register value */
@@ -76,6 +83,7 @@ static ssize_t show_word(struct device *
 			 char *buf);
 static ssize_t show_linear(struct device *dev, struct device_attribute *da,
 			 char *buf);
+static ssize_t show_vout(struct device *dev, struct device_attribute *da, char *buf);
 static ssize_t show_fan_fault(struct device *dev, struct device_attribute *da,
 			 char *buf);
 static ssize_t show_over_temp(struct device *dev, struct device_attribute *da,
@@ -121,7 +129,7 @@ static SENSOR_DEVICE_ATTR(psu_temp_fault
 static SENSOR_DEVICE_ATTR(psu_power_good,  	S_IRUGO, show_word,	  NULL, PSU_POWER_GOOD);
 static SENSOR_DEVICE_ATTR(psu_fan1_fault,  	S_IRUGO, show_fan_fault, NULL, PSU_FAN1_FAULT);
 static SENSOR_DEVICE_ATTR(psu_over_temp,   	S_IRUGO, show_over_temp, NULL, PSU_OVER_TEMP);
-static SENSOR_DEVICE_ATTR(psu_v_out,	   	S_IRUGO, show_linear,	NULL, PSU_V_OUT);
+static SENSOR_DEVICE_ATTR(psu_v_out,	   	S_IRUGO, show_vout,		NULL, PSU_V_OUT);
 static SENSOR_DEVICE_ATTR(psu_i_out,	   	S_IRUGO, show_linear,	NULL, PSU_I_OUT);
 static SENSOR_DEVICE_ATTR(psu_p_out,		S_IRUGO, show_linear,	NULL, PSU_P_OUT);
 static SENSOR_DEVICE_ATTR(psu_temp1_input, 	S_IRUGO, show_linear,	NULL, PSU_TEMP1_INPUT);
@@ -369,6 +377,37 @@ static ssize_t show_ascii(struct device
 	return sprintf(buf, "%s\n", ptr);
 }
 
+static ssize_t show_vout_by_mode(struct device *dev, struct device_attribute *da,
+             char *buf)
+{
+	struct ym2651y_data *data = ym2651y_update_device(dev);
+	int exponent, mantissa;
+	int multiplier = 1000;
+
+	if (!data->valid) {
+		return 0;
+	}
+
+	exponent = two_complement_to_int(data->vout_mode, 5, 0x1f);
+	mantissa = data->v_out;
+
+	return (exponent > 0) ? sprintf(buf, "%d\n", (mantissa << exponent) * multiplier) :
+							sprintf(buf, "%d\n", (mantissa * multiplier) / (1 << -exponent));
+}
+
+static ssize_t show_vout(struct device *dev, struct device_attribute *da,
+             char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct ym2651y_data *data = i2c_get_clientdata(client);
+
+	if (data->chip == YM2401) {
+		return show_vout_by_mode(dev, da, buf);
+	}
+
+	return show_linear(dev, da, buf);
+}
+
 static const struct attribute_group ym2651y_group = {
 	.attrs = ym2651y_attributes,
 };
@@ -395,7 +434,7 @@ static int ym2651y_probe(struct i2c_clie
 
 	i2c_set_clientdata(client, data);
 	mutex_init(&data->update_lock);
-
+	data->chip = dev_id->driver_data;
 	dev_info(&client->dev, "chip found\n");
 
 	/* Register sysfs hooks */
@@ -436,7 +475,8 @@ static int ym2651y_remove(struct i2c_cli
 }
 
 static const struct i2c_device_id ym2651y_id[] = {
-	{ "ym2651", 0 },
+	{ "ym2651", YM2651 },
+	{ "ym2401", YM2401 },
 	{}
 };
 MODULE_DEVICE_TABLE(i2c, ym2651y_id);
@@ -504,9 +544,10 @@ static struct ym2651y_data *ym2651y_upda
 
 	if (time_after(jiffies, data->last_updated + HZ + HZ / 2)
 		|| !data->valid) {
-		int i, status;
-		u8 command;
+		int i, status, length;
+		u8 command, buf;
 		struct reg_data_byte regs_byte[] = { {0x19, &data->capability},
+											 {0x20, &data->vout_mode},
 											 {0x7d, &data->over_temp},
 											 {0x81, &data->fan_fault},
 											 {0x98, &data->pmbus_revision}};
@@ -582,9 +623,17 @@ static struct ym2651y_data *ym2651y_upda
 
 		/* Read mfr_model */
 		command = 0x9a;
-		status = ym2651y_read_block(client, command, data->mfr_model,
-										 ARRAY_SIZE(data->mfr_model)-1);
-		data->mfr_model[ARRAY_SIZE(data->mfr_model)-1] = '\0';
+		length  = 1;
+		
+		/* Read first byte to determine the length of data */
+		status = ym2651y_read_block(client, command, &buf, length);
+		if (status < 0) {
+			dev_dbg(&client->dev, "reg %d, err %d\n", command, status);
+			goto exit;
+		}
+		
+		status = ym2651y_read_block(client, command, data->mfr_model, buf+1);
+		data->mfr_model[buf+1] = '\0';
 
 		if (status < 0) {
 			dev_dbg(&client->dev, "reg %d, err %d\n", command, status);
